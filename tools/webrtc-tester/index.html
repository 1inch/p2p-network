<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>WebRTC DataChannel Example</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }
    #logs {
      border: 1px solid #ccc; 
      padding: 10px; 
      width: 600px; 
      height: 300px; 
      overflow-y: scroll; 
      margin-bottom: 20px;
      background-color: #f9f9f9;
    }
    textarea, input[type="text"] {
      width: 600px; 
      padding: 10px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 16px;
    }
    button {
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      transition: background-color 0.3s ease;
    }
    button:hover {
      background-color: #45a049;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      font-size: 16px;
    }
    #publicKeyInput {
      height: 1rem;
    }
    #messageArea {
      height: 10rem;
    }
    .checkbox-container {
      margin-bottom: 10px;
    }
    .checkbox-container input {
      margin-right: 10px;
    }
  </style>
</head>
<body>
  <h1>WebRTC Data Channel Test</h1>
  <div id="logs"></div>
  <label for="publicKeyInput">Public Key (Hex):</label>
  <input type="text" id="publicKeyInput" value="039d9031e97dd78ff8c15aa86939de9b1e791066a0224e331bc962a2099a7b1f04" placeholder="Enter public key in hex" />
  <div class="checkbox-container">
    <label for="sendRawCheckbox">
      <input type="checkbox" id="sendRawCheckbox" />
      Send Raw Request
    </label>
    <label for="encryptCheckbox">
      <input type="checkbox" id="encryptCheckbox" />
      Encrypt Request
    </label>
  </div>
  <label for="messageArea">Message:</label>
  <textarea id="messageArea" placeholder="Enter message..."></textarea>
  <button id="sendBtn">Send</button>

  <script src="//cdn.jsdelivr.net/npm/protobufjs@7.X.X/dist/protobuf.min.js"></script>
  <script src="relayer_bundle.js"></script>
  <script src="elliptic.min.js"></script>

  <script>
    const EC = elliptic.ec;
    const ec = new EC('secp256k1'); 
    const keyPair = ec.genKeyPair();
    const publicKeyCompressed = keyPair.getPublic(true, 'hex');

    ////////// ECDSA //////////
    function uint8ArrayToHex(bytes) {
      return Array.from(bytes)
        .map(byte => byte.toString(16).padStart(2, '0'))
        .join('');
    }

    function hexToUint8Array(hex) {
      if (hex.length % 2 !== 0) throw new Error("Invalid hex string.");
      const array = new Uint8Array(hex.length / 2);
      for (let i = 0; i < array.length; i++) {
        array[i] = parseInt(hex.substr(i * 2, 2), 16);
      }
      return array;
    }

    function decompressPublicKey(compressedKeyHex) {
      try {
        const key = ec.keyFromPublic(compressedKeyHex, 'hex');
        const uncompressedKeyHex = key.getPublic(false, 'hex'); 
        return key;
      } catch (error) {
        log(`Error decompressing public key: ${error.message}`);
        return null;
      }
    }

    function generateEphemeralKeyPair() {
      const ephemeralKeyPair = ec.genKeyPair();
      log("[Encrypt] Ephemeral key pair generated.");
      return ephemeralKeyPair;
    }

    function deriveSharedSecretEncrypt(senderEphemeralKeyPair, receiverPublicKey) {
      try {
        // Perform scalar multiplication to get the shared point
        const sharedPoint = receiverPublicKey.getPublic().mul(senderEphemeralKeyPair.getPrivate()); 

        // Get x and y coordinates as byte arrays (32 bytes each)
        const x = sharedPoint.getX().toArray('be', 32);
        const y = sharedPoint.getY().toArray('be', 32);

        // Serialize ephemeral public key in uncompressed format (65 bytes)
        const ephemeralPubKeyUncompressedHex = senderEphemeralKeyPair.getPublic(false, 'hex');
        const ephemeralPubKeyBytes = hexToUint8Array(ephemeralPubKeyUncompressedHex);

        // Assemble the 130-byte shared secret buffer
        const buffer = new Uint8Array(65 + 1 + 32 + 32);
        buffer.set(ephemeralPubKeyBytes, 0);
        buffer.set([0x04], 65);
        buffer.set(x, 66);
        buffer.set(y, 98);

        log("[Encrypt] Derived Shared Secret (130 bytes).");
        return buffer;
      } catch (error) {
        log(`[Encrypt] Error deriving shared secret: ${error.message}`);
        return null;
      }
    }

    function deriveSharedSecretDecrypt(receiverEphemeralPublicKey, senderKeyPair) {
      try {
        // Perform scalar multiplication to get the shared point
        const sharedPoint = receiverEphemeralPublicKey.getPublic().mul(senderKeyPair.getPrivate());

        // Extract x and y coordinates (32 bytes each)
        const x = sharedPoint.getX().toArray('be', 32);
        const y = sharedPoint.getY().toArray('be', 32);

        // Serialize sender's ephemeral public key in uncompressed format (65 bytes)
        const ephemeralPubKeyUncompressedHex = receiverEphemeralPublicKey.getPublic(false, 'hex');
        const ephemeralPubKeyBytes = hexToUint8Array(ephemeralPubKeyUncompressedHex);

        // Assemble the 130-byte shared secret buffer
        const buffer = new Uint8Array(65 + 1 + 32 + 32);
        buffer.set(ephemeralPubKeyBytes, 0);
        buffer.set([0x04], 65);             
        buffer.set(x, 66);                
        buffer.set(y, 98);

        log("[Decrypt] Derived Shared Secret (130 bytes).");
        return buffer;
      } catch (error) {
        log(`[Decrypt] Error deriving shared secret: ${error.message}`);
        return null;
      }
    }

    async function deriveSymmetricKeyHKDF(sharedSecretBuffer) {
      try {
        // Import the shared secret as a key for HKDF
        const hkdfKey = await crypto.subtle.importKey(
          'raw',
          sharedSecretBuffer,
          { name: 'HKDF' },
          false,
          ['deriveKey']
        );

        // Derive the AES-GCM key using HKDF with SHA-256, no salt, no info
        const derivedKey = await crypto.subtle.deriveKey(
          {
            name: 'HKDF',
            hash: 'SHA-256',
            salt: new Uint8Array([]),
            info: new Uint8Array([])
          },
          hkdfKey,
          { name: 'AES-GCM', length: 256 },
          true,
          ['encrypt', 'decrypt']
        );

        return derivedKey;
      } catch (error) {
        log(`Error deriving symmetric key via HKDF: ${error.message}`);
        return null;
      }
    }

    function assembleEncryptedMessage(ephemeralPubKeyHex, nonce, tag, ciphertext) {
      const ephemeralPubKeyBytes = hexToUint8Array(ephemeralPubKeyHex);
      const messageBytes = new Uint8Array(
        ephemeralPubKeyBytes.length + nonce.length + tag.length + ciphertext.length
      );

      // Concatenate the parts: ephemeralPubKey + nonce + tag + ciphertext
      messageBytes.set(ephemeralPubKeyBytes, 0);
      messageBytes.set(nonce, ephemeralPubKeyBytes.length);
      messageBytes.set(tag, ephemeralPubKeyBytes.length + nonce.length);
      messageBytes.set(ciphertext, ephemeralPubKeyBytes.length + nonce.length + tag.length);

      return messageBytes;
    }

    async function encryptMessage(message, symmetricKey) {
      try {
        const encoder = new TextEncoder();
        const encodedMessage = encoder.encode(message);

        const iv = crypto.getRandomValues(new Uint8Array(16));

        // Encrypt the message
        const ciphertextBuffer = await crypto.subtle.encrypt(
          {
            name: 'AES-GCM',
            iv: iv
          },
          symmetricKey,
          encodedMessage
        );

        const ciphertextAndTag = new Uint8Array(ciphertextBuffer);

        if (ciphertextAndTag.length < 16) {
          throw new Error("Ciphertext is too short.");
        }

        // Split ciphertext and tag
        const tag = ciphertextAndTag.slice(ciphertextAndTag.length - 16);
        const ciphertext = ciphertextAndTag.slice(0, ciphertextAndTag.length - 16);

        log("[Encrypt] Message encrypted successfully.");
        return { ciphertext: ciphertext, tag: tag, iv: iv };
      } catch (error) {
        log(`[Encrypt] Error encrypting message: ${error.message}`);
        return null;
      }
    }

    async function decryptMessage(message, symmetricKey) {
      try {
        const iv = message.slice(65, 65 + 16);
        const tag = message.slice(65 + 16, 65 + 16 + 16);
        const ciphertext = message.slice(65 + 16 + 16);

        const ciphertextWithTag = new Uint8Array(ciphertext.length + tag.length);
        ciphertextWithTag.set(ciphertext, 0);
        ciphertextWithTag.set(tag, ciphertext.length);

        // Decrypt the message
        const decryptedArrayBuffer = await crypto.subtle.decrypt(
          {
            name: 'AES-GCM',
            iv: iv.buffer
          },
          symmetricKey,
          ciphertextWithTag
        );

        const decryptedBytes = new Uint8Array(decryptedArrayBuffer);
        const decoder = new TextDecoder();
        const plaintext = decoder.decode(decryptedBytes);

        log("[Decrypt] Message decrypted successfully.");
        return plaintext;
      } catch (error) {
        log(`[Decrypt] Error decrypting message: ${error.message}`);
        return null;
      }
    }

    async function encryptPayload(recipientPubKeyHex, message) {
      try {
        // Decompress recipient's public key
        const recipientKey = decompressPublicKey(recipientPubKeyHex);
        if (!recipientKey) {
          log("Failed to decompress recipient's public key.");
          return null;
        }
        
        // Generate ephemeral key pair
        const ephemeralKeyPair = generateEphemeralKeyPair();
        
        // Derive shared secret
        const sharedSecret = deriveSharedSecretEncrypt(ephemeralKeyPair, recipientKey);
        if (!sharedSecret) {
          log("[Encrypt] Failed to derive shared secret.");
          return null;
        }
        
        log("[Encrypt] Deriving Symmetric Key using HKDF.");
        const symmetricKey = await deriveSymmetricKeyHKDF(sharedSecret);
        if (!symmetricKey) {
          log("[Encrypt] Failed to derive symmetric key.");
          return null;
        }
        
        // Encrypt the message
        const encrypted = await encryptMessage(message, symmetricKey);
        if (!encrypted) {
          log("Failed to encrypt the message.");
          return null;
        }
        
        // Serialize ephemeral public key in uncompressed format
        const ephemeralPubKeyUncompressedHex = ephemeralKeyPair.getPublic(false, 'hex');
        
        // Assemble the encrypted message: ephemeralPubKey + nonce + tag + ciphertext
        const encryptedMessage = assembleEncryptedMessage(
          ephemeralPubKeyUncompressedHex,
          encrypted.iv,
          encrypted.tag,
          encrypted.ciphertext
        );
        
        return encryptedMessage;
      } catch (error) {
        log(`[Encrypt] Error encrypting payload: ${error.message}`);
        return null;
      }
    }
    async function decryptPayload(payload, privateKeyHex) {
      try {
        const ephemeralPubKeyBytes = payload.slice(0, 65);
        const ephemeralPubKeyHex = uint8ArrayToHex(ephemeralPubKeyBytes);
        const senderEphemeralKey = ec.keyFromPublic(ephemeralPubKeyHex, 'hex');

        const receiverKeyPair = ec.keyFromPrivate(privateKeyHex, 'hex');
        const sharedSecret = deriveSharedSecretDecrypt(senderEphemeralKey, receiverKeyPair);
        if (!sharedSecret) {
          log("[Decrypt] Failed to derive shared secret.");
          return null;
        }

        log("[Decrypt] Deriving Symmetric Key using HKDF.");
        const symmetricKey = await deriveSymmetricKeyHKDF(sharedSecret);
        if (!symmetricKey) {
          log("[Decrypt] Failed to derive symmetric key.");
          return null;
        }

        const decryptedPlaintext = await decryptMessage(payload, symmetricKey);

        return decryptedPlaintext;
      } catch (error) {
        return null;
      }
    }

    const { protobuf } = window;

    const {
        ErrorCode,
        Error: ErrorMessage,
        IncomingMessage,
        OutgoingMessage,
        ResolverRequest,
        ResolverResponse
    } = protobuf.roots.default.proto;

    const logDiv = document.getElementById('logs');
    function log(msg) {
      const p = document.createElement('p');
      p.textContent = msg;
      logDiv.appendChild(p);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    const messageArea = document.getElementById('messageArea');
    const sendBtn = document.getElementById('sendBtn');
    const publicKeyInput = document.getElementById('publicKeyInput');
    const sendRawCheckbox = document.getElementById('sendRawCheckbox');
    const encryptCheckbox = document.getElementById('encryptCheckbox');


    const HOST = 'http://161.35.27.188:10003';
    const SDP_ENDPOINT = `${HOST}/sdp`;
    const CANDIDATE_ENDPOINT = `${HOST}/candidate`;
    const SESSION_ID = 'webrtc-session';

    let pc; 
    let dataChannel;

    async function startWebRTC() {
      pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
      });

      dataChannel = pc.createDataChannel("myDataChannel");

      dataChannel.onopen = () => {
        log("[DataChannel] State: " + dataChannel.readyState);
        log("[DataChannel] Current session key pair generated.");
      };
      dataChannel.onclose = () => {
        log("[DataChannel] Closed.");
      };
      dataChannel.onmessage = async (event) => {
        try {
          const encrypt = encryptCheckbox.checked;

          const incomingBuffer = new Uint8Array(event.data);
          const incomingMsg = OutgoingMessage.decode(incomingBuffer);

          if (incomingMsg.response && incomingMsg.response.payload) {
            if (encrypt) {
              const decryptedMsg = await decryptPayload(incomingMsg.response.payload, keyPair.getPrivate('hex'));
              log("[DataChannel] Raw encrypted response: " + uint8ArrayToHex(incomingMsg.response.payload));
              log("[DataChannel] Decrypted response: " + decryptedMsg);
            } else {
              const payload = new TextDecoder().decode(incomingMsg.response.payload);
              log("[DataChannel] Received unencrypted response: " + payload);
            }
          } else if (incomingMsg.error) {
            log("[DataChannel] Received Error: " + incomingMsg.error.message);
          }
        } catch (err) {
          log("[DataChannel] Error decoding message: " + err);
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          let candidate = parsePionCandidate(event.candidate.candidate);
          const candidatePayload = {
            session_id: SESSION_ID,
            candidate: candidate
          };
          fetch(CANDIDATE_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(candidatePayload)
          })
          .then(() => log("[ICE] Sent candidate."))
          .catch(err => log("[ICE] Error sending candidate: " + err));
        } else {
          log("[ICE] No more candidates or gathering done.");
        }
      };

      pc.oniceconnectionstatechange = () => {
        log("[ICE] ICE Connection State: " + pc.iceConnectionState);
      };

      pc.onconnectionstatechange = () => {
        log("[PC] Connection State: " + pc.connectionState);
      };
      pc.onsignalingstatechange = () => {
        log("[PC] Signaling State: " + pc.signalingState);
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log("[Offer] Created and set local description.");

      const offerPayload = {
        session_id: SESSION_ID,
        offer: {
          type: offer.type,
          sdp: offer.sdp
        }
      };

      fetch(SDP_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(offerPayload)
      })
      .then(response => response.json())
      .then(async (data) => {
        if (!data.answer || !data.answer.sdp) {
          throw new Error("No valid answer in response");
        }
        log("[Offer] Received answer from server.");

        const remoteAnswer = new RTCSessionDescription({
          type: data.answer.type,
          sdp: data.answer.sdp
        });
        await pc.setRemoteDescription(remoteAnswer);
        log("[Answer] Remote description set.");
      })
      .catch(err => {
        log("[Offer] Error receiving answer: " + err);
      });
    }

    startWebRTC().catch(err => log("Error initializing WebRTC: " + err));

    sendBtn.onclick = async () => {
      if (!dataChannel || dataChannel.readyState !== "open") {
        log("[DataChannel] Data channel not open.");
        return;
      }
      const msg = messageArea.value.trim();
      if (!msg) {
        log("[DataChannel] Message is empty.");
        return;
      }

      const pubKey = publicKeyInput.value.trim();
      if (!pubKey) {
        log("[DataChannel] Public key is empty.");
        return;
      }

      let message;

      const sendRaw = sendRawCheckbox.checked;
      const encrypt = encryptCheckbox.checked;

      if (sendRaw) {
        message = msg;
      } else {
        let payload;
        if (encrypt) {
          payload = await encryptPayload(pubKey, msg);
          log("[DataChannel] Raw unencrypted message: " + msg);
          log("[DataChannel] Encrypted message sent: " + uint8ArrayToHex(payload));
        } else {
          log("[DataChannel] Unencrypted message sent: " + msg);
          payload = new TextEncoder().encode(msg);
        }

        const outgoingMsg = IncomingMessage.create({
          request: ResolverRequest.create({
            id: "resolver-request",
            payload: payload,
            encrypted: encrypt,
            publicKey: hexToUint8Array(publicKeyCompressed),
          }),
          publicKeys: [hexToUint8Array(pubKey)]
        });

        message = IncomingMessage.encode(outgoingMsg).finish();
      }

      dataChannel.send(message);
      messageArea.value = "";
    };

    function parsePionCandidate(candidateLine) {
      const parts = candidateLine.trim().split(/\s+/);
      if (!parts[0].startsWith("candidate:") || parts.length < 8) {
        throw new Error("Invalid ICE candidate string format: " + candidateLine);
      }
      const foundation = parts[0].split(":")[1];
      const component = parseInt(parts[1], 10);
      const protocol = parts[2];
      const priority = parseInt(parts[3], 10);
      const address = parts[4];
      const port = parseInt(parts[5], 10);
      if (parts[6] !== "typ") {
        throw new Error(`Expected 'typ' at position 6 but got: ${parts[6]}`);
      }
      const candidateType = parts[7];

      let relatedAddress = "";
      let relatedPort = 0;
      let tcpType = "";
      let i = 8;
      while (i < parts.length) {
        switch (parts[i]) {
          case "raddr":
            relatedAddress = parts[i + 1] || "";
            i += 2;
            break;
          case "rport":
            relatedPort = parseInt(parts[i + 1], 10) || 0;
            i += 2;
            break;
          case "tcptype":
            tcpType = parts[i + 1] || "";
            i += 2;
            break;
          default:
            i += 1;
        }
      }

      return {
        foundation,
        priority,
        address,
        protocol: parseProtocol(protocol),
        port,
        type: candidateType,
        component,
        relatedAddress,
        relatedPort,
        tcpType,
      };
    }

    function parseProtocol(protocolStr) {
      switch (protocolStr) {
        case "udp":
          return 1;
        case "tcp":
          return 2;
        default:
          return 0;
      }
    }
  </script>
</body>
</html>
